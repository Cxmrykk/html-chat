<!doctype html>
<!--
=========================================================================================
RULES FOR CONTINUED EXISTENCE:
1. NO BULLSHIT FRAMEWORKS. If you think this needs React, you are the problem.
2. NO BUILD TOOLS. If it doesn't run by double-clicking the .html file, delete it.
3. DEPENDENCY HONESTY. We use Marked, KaTeX, and Prism because we aren't masochists.
   We value our time and sanity more than loading 100kb of minified JS.
4. SINGLE FILE SUPREMACY. If it can't live in this one file, it doesn't deserve to live.
5. PERFORMANCE IS A FEATURE. We don't animate. We don't fade. We don't "hydrate."
   We render the fucking HTML and we get out of the way.

"A designer knows he has achieved perfection not when there is nothing left to add, 
but when there is nothing left to take away." — Some dead guy.
=========================================================================================
-->
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>HTML Chat</title>

    <!-- Yeah, I'm loading a 30kb script for Markdown. Writing a regex parser for this shit is a waste of time. Deal with it. -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <!-- The math shit. Unless you like reading raw latex, we're gonna need this too. -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css" />
    <script src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/auto-render.min.js"></script>

    <!-- I'd rather neck myself than stare at a gray wall of text. -->
    <link href="https://cdn.jsdelivr.net/npm/prismjs/themes/prism.min.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/prismjs/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"></script>

    <style>
      /* Just enough CSS so it doesn't look like shit. */
      body {
        max-width: 1000px;
        margin: 0 auto;
        height: 100vh;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        font-family: monospace, sans-serif;
        line-height: 1.6;
        padding: 2rem 1rem 1rem 1rem;
        color: #111;
        background: #fafafa;
        overflow: hidden; /* NO BODY SCROLLING. EVER. */
      }

      header {
        flex-shrink: 0; /* Prevents the header from getting squished */
      }

      h1,
      h2,
      h3 {
        margin-top: 0;
      }
      button {
        cursor: pointer;
        font-family: inherit;
        background: #eee;
        border: 1px solid #000;
        padding: 5px 10px;
        color: #000;
      }
      button:hover {
        background: #ccc;
      }
      input[type="text"],
      input[type="password"],
      textarea,
      select {
        font-family: inherit;
        padding: 8px;
        border: 1px solid #000;
        box-sizing: border-box;
        width: 100%;
        margin-bottom: 10px;
        background: #fff;
      }
      textarea {
        min-height: 100px;
        resize: vertical;
      }
      .hidden {
        display: none !important;
      }

      /* Top Actions */
      .top-actions {
        position: fixed;
        top: 1rem;
        right: 1rem;
        display: flex;
        gap: 15px;
        z-index: 100;
      }
      .top-btn {
        color: #0055ff;
        text-decoration: underline;
        cursor: pointer;
        font-size: 0.9em;
      }
      .top-btn:hover {
        color: #ff0055;
      }

      /* Layout */
      .grid {
        display: flex;
        gap: 2rem;
        flex-grow: 1;
        min-height: 0; /* Forces flexbox to respect boundaries */
        margin-top: 1rem;
      }

      /* Basic mobile support so it doesn't look like shit on a phone */
      @media (max-width: 768px) {
        .grid {
          flex-direction: column;
        }
        .sidebar {
          flex: 0 0 30%;
          min-height: 0;
        }
      }

      /* Sidebar with its own fucking scroll context */
      .sidebar {
        flex: 1;
        min-width: 250px;
        overflow-y: auto;
        padding-right: 10px;
      }

      .main {
        flex: 3;
        min-width: 300px;
        display: flex;
        flex-direction: column;
        min-height: 0;
      }

      /* Chat Container */
      #chat-container {
        position: relative;
        flex-grow: 1;
        min-height: 0; /* Let it actually shrink */
        overflow-y: auto;
        border: 2px solid #000;
        background: #ebebeb;
        padding: 15px;
        margin-bottom: 15px;
      }

      #input-area {
        flex-shrink: 0; /* Prevents the text area from being crushed by the chat container */
      }

      /* Chat Messages */
      .msg {
        border-left: 4px solid #000;
        padding-left: 15px;
        margin-bottom: 20px;
        background: #fff;
        padding-top: 10px;
        padding-bottom: 10px;
        padding-right: 10px;
        border-radius: 0 5px 5px 0;
        box-shadow: 2px 2px 0px #000;
      }
      .msg:last-child {
        margin-bottom: 0;
      }
      .msg.user {
        border-color: #0055ff;
      }
      .msg.assistant {
        border-color: #ff0055;
      }
      .msg.system {
        border-color: #ffaa00;
        background: #fff8e6;
      }

      .msg-meta {
        font-size: 0.85em;
        text-transform: uppercase;
        font-weight: bold;
        margin-bottom: 10px;
        color: #555;
        display: flex;
        justify-content: space-between;
      }
      .msg-actions button {
        font-size: 0.8em;
        padding: 2px 6px;
        margin-left: 5px;
      }
      .msg-content {
        overflow-wrap: anywhere;
      }
      .msg-content p:first-child {
        margin-top: 0;
      }
      .msg-content p:last-child {
        margin-bottom: 0;
      }

      /* Markdown Code Blocks */
      .msg-content pre {
        padding: 10px;
        border: 1px solid #000;
        overflow-x: auto;
        overflow-y: hidden;
        max-height: none !important; /* Override any Prism.js max-height bullshit */
        border-radius: 0;
      }
      .msg-content code {
        background: #eee;
        padding: 2px 4px;
        color: #000;
      }
      .msg-content pre code {
        padding: 0;
        background: transparent;
        color: inherit;
      }

      /* Override Prism's soft bullshit without breaking hover states */
      .msg-content pre[class*="language-"] {
        background: #eee;
        margin: 0.5em 0;
        text-shadow: none;
      }
      .msg-content code[class*="language-"],
      .msg-content pre[class*="language-"] {
        font-family: inherit;
        font-size: 0.9em;
        line-height: 1.6;
        direction: ltr;
      }

      /* Highlight the whole block on Ctrl-Copy hover */
      body.ctrl-down .msg-content pre[class*="language-"]:hover {
        background: #e0e0e0;
      }
      body.ctrl-down pre:hover code {
        background: transparent; /* Stop the text from highlighting independently */
      }

      /* Edit Area */
      .edit-area {
        min-height: 250px;
      }

      /* Chat List */
      .chat-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 5px;
        border: 1px solid transparent;
        margin-bottom: 5px;
      }
      .chat-item.active {
        border-color: #000;
        background: #eee;
        font-weight: bold;
      }
      .chat-item-title {
        cursor: pointer;
        flex-grow: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        min-width: 0;
        margin-right: 10px;
      }
      .chat-item-actions {
        flex-shrink: 0;
        display: flex;
      }
      .chat-item-actions button {
        font-size: 0.7em;
        padding: 2px 5px;
        margin-left: 2px;
      }

      /* Config */
      .config-box {
        background: #eee;
        padding: 15px;
        border: 1px solid #000;
        margin-bottom: 20px;
      }
      .checkbox-label {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 10px;
        cursor: pointer;
      }

      body.ctrl-down pre,
      body.ctrl-down code,
      body.ctrl-down .katex {
        cursor: pointer !important;
      }

      /* CTRL-Copy */
      body.ctrl-down pre:hover,
      body.ctrl-down code:hover,
      body.ctrl-down .katex:hover,
      body.ctrl-down .chat-item:hover {
        background: #e0e0e0;
      }

      body.ctrl-down .chat-item-title {
        cursor: copy !important;
      }

      /* Latex */
      .katex {
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
      }
    </style>
  </head>
  <body>
    <div class="top-actions">
      <a id="toggle-title-btn" class="top-btn" title="Alt+O" onclick="toggleTitle()">[hide title]</a>
      <a id="toggle-sidebar-btn" class="top-btn" title="Alt+P" onclick="toggleSidebar()">[hide sidebar]</a>
    </div>

    <header>
      <h1>HTML Chat</h1>
      <p>No 500MB Docker containers. No bullshit. Just you, your API key, and the fucking browser.</p>
    </header>

    <div class="grid">
      <!-- SIDEBAR: Config & Chat List -->
      <aside class="sidebar" id="sidebar">
        <div class="config-box">
          <h3>Settings</h3>
          <label>Base URL</label>
          <input type="text" id="cfg-url" placeholder="https://api.openai.com/v1" />

          <label>API Key</label>
          <input type="password" id="cfg-key" placeholder="sk-..." />

          <label>Models (use commas)</label>
          <input type="text" id="cfg-models" placeholder="gpt-4o,gpt-3.5-turbo" />

          <label class="checkbox-label">
            <input type="checkbox" id="cfg-godmode" />
            <strong>God-Mode (JS Exec)</strong>
          </label>

          <button onclick="saveConfig()">Save Settings</button>
        </div>

        <div>
          <div style="display: flex; justify-content: space-between; align-items: center">
            <h3>Your Chats</h3>
            <button onclick="newChat()" title="Alt+T">+ New</button>
          </div>
          <div id="chat-list"></div>
        </div>
      </aside>

      <!-- MAIN: Chat Area -->
      <main class="main">
        <div id="chat-container">
          <!-- Messages go here -->
        </div>

        <div id="input-area">
          <div style="display: flex; gap: 10px; margin-bottom: 10px">
            <select id="model-select" style="width: auto; margin: 0"></select>
            <button
              id="send-btn"
              onclick="sendMessage()"
              title="Ctrl+Enter / Cmd+Enter"
              style="flex-grow: 1; font-weight: bold"
            >
              Send
            </button>
          </div>
          <textarea id="chat-input" placeholder="Type your prompt here..."></textarea>
        </div>
      </main>
    </div>

    <script>
      // --- STATE MANAGEMENT ---
      let config = JSON.parse(localStorage.getItem("mf_config")) || {
        url: "https://api.openai.com/v1",
        key: "",
        models: "gpt-4o, gpt-4-turbo, gpt-3.5-turbo",
        godMode: false,
      };
      let chats = JSON.parse(localStorage.getItem("mf_chats")) || [];
      let currentChatId = localStorage.getItem("mf_current_chat_id") || null;
      let currentAbortController = null;

      let isSidebarHidden =
        localStorage.getItem("mf_sidebar_hidden") === "true" || localStorage.getItem("mf_locked_in") === "true";
      let isTitleHidden = localStorage.getItem("mf_title_hidden") === "true";

      function saveState() {
        localStorage.setItem("mf_config", JSON.stringify(config));
        localStorage.setItem("mf_chats", JSON.stringify(chats));
        localStorage.setItem("mf_current_chat_id", currentChatId || "");
        localStorage.setItem("mf_sidebar_hidden", isSidebarHidden);
        localStorage.setItem("mf_title_hidden", isTitleHidden);
      }

      // --- INITIALIZATION ---
      function init() {
        document.getElementById("cfg-url").value = config.url;
        document.getElementById("cfg-key").value = config.key;
        document.getElementById("cfg-models").value = config.models;
        document.getElementById("cfg-godmode").checked = config.godMode || false;

        updateModelDropdown();
        applySidebarState();
        applyTitleState();

        if (!currentChatId && chats.length > 0) {
          currentChatId = chats[0].id;
        }

        renderApp();
      }

      function toggleSidebar() {
        isSidebarHidden = !isSidebarHidden;
        saveState();
        applySidebarState();
      }

      function applySidebarState() {
        const sidebar = document.getElementById("sidebar");
        const btn = document.getElementById("toggle-sidebar-btn");
        if (isSidebarHidden) {
          sidebar.classList.add("hidden");
          btn.textContent = "[show sidebar]";
        } else {
          sidebar.classList.remove("hidden");
          btn.textContent = "[hide sidebar]";
        }
      }

      function toggleTitle() {
        isTitleHidden = !isTitleHidden;
        saveState();
        applyTitleState();
      }

      function applyTitleState() {
        const header = document.querySelector("header");
        const btn = document.getElementById("toggle-title-btn");
        if (isTitleHidden) {
          header.classList.add("hidden");
          btn.textContent = "[show title]";
        } else {
          header.classList.remove("hidden");
          btn.textContent = "[hide title]";
        }
      }

      function saveConfig() {
        config.url = document.getElementById("cfg-url").value.trim();
        config.key = document.getElementById("cfg-key").value.trim();
        config.models = document.getElementById("cfg-models").value.trim();
        config.godMode = document.getElementById("cfg-godmode").checked;
        saveState();
        updateModelDropdown();
        alert("Settings saved, don't fuck them up.");
      }

      function updateModelDropdown() {
        const select = document.getElementById("model-select");
        select.innerHTML = "";
        const models = config.models
          .split(",")
          .map((m) => m.trim())
          .filter((m) => m);
        models.forEach((m) => {
          const opt = document.createElement("option");
          opt.value = m;
          opt.textContent = m;
          select.appendChild(opt);
        });
      }

      // --- CHAT MANAGEMENT ---
      function newChat() {
        const id = Date.now().toString();
        chats.unshift({ id, title: "New Chat", messages: [] });
        currentChatId = id;
        saveState();
        renderApp();
      }

      function loadChat(id) {
        currentChatId = id;
        saveState();
        renderApp();
      }

      function deleteChat(id) {
        chats = chats.filter((c) => c.id !== id);
        if (currentChatId === id) currentChatId = chats.length ? chats[0].id : null;
        saveState();
        renderApp();
      }

      function renameChat(id) {
        const chat = chats.find((c) => c.id === id);
        const newTitle = prompt("Rename chat:", chat.title);
        if (newTitle) {
          chat.title = newTitle.trim();
          saveState();
          renderApp(true);
        }
      }

      function forkChat(msgIndex) {
        const chat = chats.find((c) => c.id === currentChatId);
        const newId = Date.now().toString();
        const forkedMessages = JSON.parse(JSON.stringify(chat.messages.slice(0, msgIndex + 1)));

        chats.unshift({
          id: newId,
          title: chat.title + " (Forked)",
          messages: forkedMessages,
        });

        currentChatId = newId;
        saveState();
        renderApp();
      }

      function copyChat(chat, element) {
        if (chat.messages.length === 0) {
          alert("Chat is empty, nothing to copy.");
          return;
        }

        let formattedText = `# ${chat.title}\n\n`;
        chat.messages.forEach((msg) => {
          const role = msg.role.toUpperCase();
          formattedText += `## ${role}\n${msg.content}\n\n`;
        });

        navigator.clipboard.writeText(formattedText.trim()).then(() => {
          const originalBg = element.style.backgroundColor;
          element.style.backgroundColor = "#ccc";
          setTimeout(() => {
            element.style.backgroundColor = originalBg;
          }, 150);
        });
      }

      function retryMessage(msgIndex) {
        const chat = chats.find((c) => c.id === currentChatId);
        const textToRetry = chat.messages[msgIndex].content;

        chat.messages = chat.messages.slice(0, msgIndex);
        saveState();

        document.getElementById("chat-input").value = textToRetry;
        sendMessage();
      }

      function deleteMessage(msgIndex) {
        const chat = chats.find((c) => c.id === currentChatId);
        chat.messages.splice(msgIndex, 1);
        saveState();
        renderApp(true);
      }

      // --- RENDERING ---
      function renderApp(preserveScroll = false) {
        renderChatList();
        renderCurrentChat(preserveScroll);
      }

      function renderChatList() {
        const list = document.getElementById("chat-list");
        list.innerHTML = "";

        if (chats.length === 0) {
          list.innerHTML = '<p style="font-size:0.8em; color:#666;">No chats. Start a new one, asshole.</p>';
          return;
        }

        chats.forEach((chat) => {
          const div = document.createElement("div");
          div.className = `chat-item ${chat.id === currentChatId ? "active" : ""}`;

          const title = document.createElement("div");
          title.className = "chat-item-title";
          title.textContent = chat.title;

          title.onclick = (e) => {
            if (e.ctrlKey || e.metaKey) {
              copyChat(chat, div);
            } else {
              loadChat(chat.id);
            }
          };

          const actions = document.createElement("div");
          actions.className = "chat-item-actions";

          const renBtn = document.createElement("button");
          renBtn.textContent = "✎";
          renBtn.title = chat.id === currentChatId ? "Rename (Alt+R)" : "Rename";
          renBtn.onclick = () => renameChat(chat.id);

          const delBtn = document.createElement("button");
          delBtn.textContent = "×";
          delBtn.title = chat.id === currentChatId ? "Delete (Alt+W)" : "Delete";
          delBtn.onclick = () => {
            if (confirm("Are you sure you want to nuke this chat?")) {
              deleteChat(chat.id);
            }
          };

          actions.appendChild(renBtn);
          actions.appendChild(delBtn);

          div.appendChild(title);
          div.appendChild(actions);
          list.appendChild(div);
        });
      }

      function renderCurrentChat(preserveScroll = false) {
        const container = document.getElementById("chat-container");
        const prevScroll = container.scrollTop;

        container.innerHTML = "";

        if (!currentChatId) {
          container.innerHTML = '<h3 style="margin:0;">No chat selected.</h3>';
          return;
        }

        const chat = chats.find((c) => c.id === currentChatId);
        if (chat.messages.length === 0) {
          container.innerHTML = '<p style="margin:0;">It is fucking empty in here. Send a prompt.</p>';
          return;
        }

        chat.messages.forEach((msg, index) => {
          const msgDiv = document.createElement("div");
          msgDiv.className = `msg ${msg.role}`;

          const metaDiv = document.createElement("div");
          metaDiv.className = "msg-meta";

          const roleSpan = document.createElement("span");
          roleSpan.textContent = msg.role;

          const actionsDiv = document.createElement("div");
          actionsDiv.className = "msg-actions";

          const editBtn = document.createElement("button");
          editBtn.textContent = "Edit";

          const forkBtn = document.createElement("button");
          forkBtn.textContent = "Fork";
          forkBtn.onclick = () => forkChat(index);

          actionsDiv.appendChild(editBtn);
          actionsDiv.appendChild(forkBtn);

          if (msg.role === "user") {
            const retryBtn = document.createElement("button");
            retryBtn.textContent = "Retry";
            retryBtn.onclick = () => retryMessage(index);
            actionsDiv.appendChild(retryBtn);
          }

          const delBtn = document.createElement("button");
          delBtn.textContent = "Delete";
          delBtn.onclick = () => deleteMessage(index);

          actionsDiv.appendChild(delBtn);

          metaDiv.appendChild(roleSpan);
          metaDiv.appendChild(actionsDiv);

          // Content area
          const contentDiv = document.createElement("div");
          contentDiv.className = "msg-content";

          // Ensure content is always a string to prevent regex crashes
          const safeContent = msg.content || "";

          // 1. Extract math blocks so marked.js doesn't fuck up underscores and asterisks
          const mathBlocks = [];
          const placeholderContent = safeContent.replace(/(\$\$)([\s\S]*?)\1|\$((?:\\.|[^$\n])+?)\$/g, (match) => {
            const safeMath = match.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
            mathBlocks.push(safeMath);
            return `%%%MATH${mathBlocks.length - 1}%%%`;
          });

          let parsedContent = marked.parse(placeholderContent);

          parsedContent = parsedContent.replace(/%%%MATH(\d+)%%%/g, (match, i) => {
            return mathBlocks[i];
          });

          contentDiv.innerHTML = parsedContent;

          const editArea = document.createElement("textarea");
          editArea.className = "hidden edit-area";
          editArea.value = msg.content;

          const editActionsContainer = document.createElement("div");
          editActionsContainer.className = "hidden";
          editActionsContainer.style.marginTop = "5px";

          const saveEditBtn = document.createElement("button");
          saveEditBtn.textContent = "Save";

          const cancelEditBtn = document.createElement("button");
          cancelEditBtn.textContent = "Cancel";
          cancelEditBtn.style.marginLeft = "5px";

          const toggleWrapBtn = document.createElement("button");
          toggleWrapBtn.textContent = "Toggle Wrap";
          toggleWrapBtn.style.marginLeft = "5px";

          toggleWrapBtn.onclick = () => {
            editArea.style.whiteSpace = editArea.style.whiteSpace === "pre" ? "pre-wrap" : "pre";
            editArea.style.overflowX = editArea.style.whiteSpace === "pre" ? "auto" : "hidden";
          };

          editActionsContainer.appendChild(saveEditBtn);
          editActionsContainer.appendChild(cancelEditBtn);
          editActionsContainer.appendChild(toggleWrapBtn);

          editBtn.onclick = () => {
            contentDiv.classList.add("hidden");
            editArea.classList.remove("hidden");
            editActionsContainer.classList.remove("hidden");
            editBtn.classList.add("hidden");
            editArea.focus();
          };

          cancelEditBtn.onclick = () => {
            renderApp(true);
          };

          saveEditBtn.onclick = () => {
            msg.content = editArea.value;
            saveState();
            renderApp(true);
          };

          msgDiv.appendChild(metaDiv);
          msgDiv.appendChild(contentDiv);
          msgDiv.appendChild(editArea);
          msgDiv.appendChild(editActionsContainer);

          container.appendChild(msgDiv);

          renderMathInElement(msgDiv, {
            delimiters: [
              { left: "$$", right: "$$", display: true },
              { left: "$", right: "$", display: false },
            ],
            output: "htmlAndMathml",
            throwOnError: false,
          });

          Prism.highlightAllUnder(msgDiv);
        });

        if (preserveScroll) {
          container.scrollTop = prevScroll;
        } else {
          const lastMsg = container.lastElementChild;
          if (lastMsg) {
            container.scrollTop = lastMsg.offsetTop - 15;
          }
        }
      }

      // --- API INTERACTION & GOD MODE LOOP ---
      async function sendMessage(autoLoopDepth = 0) {
        const btn = document.getElementById("send-btn");
        const MAX_LOOPS = 5; // The Kill Switch

        // If we hit the loop limit, forcefully stop the recursion
        if (autoLoopDepth >= MAX_LOOPS) {
          const chat = chats.find((c) => c.id === currentChatId);
          chat.messages.push({
            role: "system",
            content: `**System Error:** Maximum execution loop depth (${MAX_LOOPS}) reached. The LLM was forcefully stopped to prevent an infinite loop.`,
          });
          saveState();
          renderApp();
          btn.textContent = "Send";
          return;
        }

        const isAutoLoop = autoLoopDepth > 0;

        if (currentAbortController && !isAutoLoop) {
          currentAbortController.abort();
          currentAbortController = null;
          btn.textContent = "Send";
          return;
        }

        const inputEl = document.getElementById("chat-input");
        const text = inputEl.value.trim();

        if (!isAutoLoop) {
          if (!text) return;
          if (!config.key) {
            alert("Please enter your API key in the settings first.");
            return;
          }
          if (!currentChatId) newChat();
        }

        const chat = chats.find((c) => c.id === currentChatId);

        if (!isAutoLoop) {
          if (chat.messages.length === 0) {
            chat.title = text.substring(0, 30) + (text.length > 30 ? "..." : "");
          }
          chat.messages.push({ role: "user", content: text });
          inputEl.value = "";
          saveState();
          renderApp();
        }

        const model = document.getElementById("model-select").value;
        currentAbortController = new AbortController();

        // Update button text to show loop depth
        btn.textContent = isAutoLoop ? `Thinking (Loop ${autoLoopDepth}/${MAX_LOOPS})...` : "Thinking...";

        try {
          const cleanMessages = chat.messages
            .filter((m) => {
              // Keep all user and assistant messages
              if (m.role !== "system") return true;
              // Keep "Executing Code" system messages so the LLM has context
              if (m.content && m.content.includes("**Executing Code:**")) return true;
              // Filter out other system messages (like errors)
              return false;
            })
            .map((m) => {
              let apiRole = m.role;
              // Map "Executing Code" (system) to "user" for the API so the LLM sees it as context
              if (apiRole === "system" && m.content.includes("**Executing Code:**")) {
                apiRole = "user";
              }
              return { role: apiRole, content: m.content || "" };
            });

          if (config.godMode) {
            cleanMessages.unshift({
              role: "system",
              content: `[SYSTEM OVERRIDE: CODE EXECUTION ENABLED]
You are executing directly inside the user's web browser (JS console). You are NOT in a sandboxed cloud environment. You are NOT in Node.js or Python. You have full, unrestricted access to the user's 'window', 'document', 'navigator', 'localStorage', etc.

However, to execute code, you MUST use this exact syntax:
<run>
// browser-side JS goes here
return window.innerWidth;
</run>

CRITICAL RULES FOR TOOL USE:
1. DO NOT CALCULATE MANUALLY. If the user asks a math, logic, or data question, you MUST use a <run> block to compute it. Do not trust your own internal math.
2. NO FAKE CODE OR COMMENT SCRATCHPADS. Your JavaScript MUST contain actual logic, algorithms, math, or simulations. DO NOT write paragraphs of text in JS comments to "think" and then return a hardcoded guess. The code itself must do the actual work to solve the problem.
3. DEFER YOUR ANSWER. If you output a <run> block, DO NOT attempt to answer the user's prompt in the same message. Output ONLY your thought process and the <run> block.
4. WAIT FOR THE RESULT. The system will execute your code and return the result in the next message.
5. DELIVER THE FINAL ANSWER ONLY AFTER EXECUTION. Unless an error is spotted, once you have the results write your final response to the user and DO NOT include any <run> tags.
6. NEVER use Node.js modules (require, os, fs). They do not exist here.
7. NEVER use markdown backticks (\`\`\`) around the <run> tags. Just output the raw tags.

EXAMPLE WORKFLOW:
User: What is the square root of 9999?
Assistant: I need to compute this using JavaScript.
<run>
return Math.sqrt(9999);
</run>
User: **Execution Result:**
\`\`\`text
Return: 99.99499987499375
\`\`\`
Assistant: The square root of 9999 is 99.994999875.`,
            });
          }

          const response = await fetch(`${config.url}/chat/completions`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${config.key}`,
            },
            body: JSON.stringify({
              model: model,
              messages: cleanMessages,
            }),
            signal: currentAbortController.signal,
          });

          if (!response.ok) {
            const errData = await response.json().catch(() => ({}));
            throw new Error(errData.error?.message || `HTTP ${response.status} ${response.statusText}`);
          }

          const data = await response.json();
          const reply = data.choices[0].message.content || "";

          // --- GOD MODE INTERCEPTOR & QUEUE ---
          if (config.godMode && reply) {
            const runMatches = [...reply.matchAll(/<run>([\s\S]*?)<\/run>/g)];

            if (runMatches.length > 0) {
              let assistantContent = reply.replace(/<run>[\s\S]*?<\/run>/g, "").trim();

              if (assistantContent === "") {
                assistantContent = "*(Executing code...)*";
              }

              chat.messages.push({ role: "assistant", content: assistantContent });
              saveState();
              renderApp();

              for (const match of runMatches) {
                const code = match[1].trim();

                // Store Code as SYSTEM (Visual log, not editable)
                chat.messages.push({
                  role: "system",
                  content: `**Executing Code:**\n\`\`\`javascript\n${code}\n\`\`\``,
                });
                saveState();
                renderApp();

                let logs = [];
                const safeStringify = (obj) => {
                  try {
                    return typeof obj === "object" ? JSON.stringify(obj, null, 2) : String(obj);
                  } catch (e) {
                    return Object.prototype.toString.call(obj);
                  }
                };

                const proxyConsole = {
                  log: (...args) => logs.push(args.map(safeStringify).join(" ")),
                  error: (...args) => logs.push("ERROR: " + args.map(safeStringify).join(" ")),
                };

                let result;
                let errorStr = "";

                try {
                  const AsyncFunction = Object.getPrototypeOf(async function () {}).constructor;
                  const execFn = new AsyncFunction("console", code);
                  result = await execFn(proxyConsole);
                } catch (err) {
                  errorStr = err.toString();
                }

                let outputMsg = "**Execution Result:**\n```text\n";
                if (logs.length > 0) outputMsg += logs.join("\n") + "\n";
                if (result !== undefined) outputMsg += "Return: " + safeStringify(result) + "\n";
                if (errorStr) outputMsg += "Error: " + errorStr + "\n";
                if (logs.length === 0 && result === undefined && !errorStr)
                  outputMsg += "Code executed successfully with no output.\n";
                outputMsg += "```";

                // Store Result as USER (Editable, Retry-able)
                chat.messages.push({ role: "user", content: outputMsg });
                saveState();
                renderApp();
              }

              // Recursively call sendMessage with an incremented loop depth
              return sendMessage(autoLoopDepth + 1);
            } else {
              if (reply.trim() !== "" || isAutoLoop) {
                chat.messages.push({ role: "assistant", content: reply });
                saveState();
                renderApp();
              }
            }
          } else {
            if (reply.trim() !== "" || isAutoLoop) {
              chat.messages.push({ role: "assistant", content: reply });
              saveState();
              renderApp();
            }
          }
        } catch (error) {
          if (error.name === "AbortError") {
            chat.messages.push({ role: "system", content: "**System:** Request cancelled by user." });
          } else {
            chat.messages.push({ role: "system", content: `**Error:**\n\n${error.message}` });
          }
        }

        currentAbortController = null;
        btn.textContent = "Send";
        saveState();
        renderApp();
      }

      // --- KEYBOARD SHORTCUTS ---
      document.getElementById("chat-input").addEventListener("keydown", function (e) {
        if ((e.ctrlKey || e.metaKey) && e.key === "Enter") {
          sendMessage();
        }
      });

      document.addEventListener("keydown", function (e) {
        if (e.altKey && e.key.toLowerCase() === "t") {
          e.preventDefault();
          newChat();
          document.getElementById("chat-input").focus();
        }
        if (e.altKey && e.key.toLowerCase() === "w") {
          e.preventDefault();
          if (currentChatId) {
            if (confirm("Are you sure you want to nuke this chat?")) {
              deleteChat(currentChatId);
            }
          }
        }
        if (e.altKey && e.key.toLowerCase() === "r") {
          e.preventDefault();
          renameChat(currentChatId);
        }
        if (e.altKey && e.key.toLowerCase() === "p") {
          e.preventDefault();
          toggleSidebar();
        }
        if (e.altKey && e.key.toLowerCase() === "o") {
          e.preventDefault();
          toggleTitle();
        }
        if (e.altKey && (e.key === "ArrowUp" || e.key === "ArrowDown")) {
          e.preventDefault();
          const container = document.getElementById("chat-container");
          const msgs = Array.from(container.querySelectorAll(".msg"));
          if (msgs.length === 0) return;

          const currentScroll = container.scrollTop;
          const offsetAdjustment = 15;
          const threshold = 5;

          if (e.key === "ArrowDown") {
            const nextMsg = msgs.find((m) => m.offsetTop - offsetAdjustment > currentScroll + threshold);
            if (nextMsg) {
              container.scrollTop = nextMsg.offsetTop - offsetAdjustment;
            } else {
              container.scrollTop = container.scrollHeight;
            }
          } else if (e.key === "ArrowUp") {
            const prevMsg = msgs
              .slice()
              .reverse()
              .find((m) => m.offsetTop - offsetAdjustment < currentScroll - threshold);
            if (prevMsg) {
              container.scrollTop = prevMsg.offsetTop - offsetAdjustment;
            } else {
              container.scrollTop = 0;
            }
          }
        }
      });

      // --- CLIPBOARD SHIT ---
      const toggleCopyMode = (e) => {
        if (e.key === "Control" || e.key === "Meta") {
          document.body.classList.toggle("ctrl-down", e.type === "keydown");
        }
      };

      window.addEventListener("keydown", toggleCopyMode);
      window.addEventListener("keyup", toggleCopyMode);
      window.addEventListener("blur", () => {
        document.body.classList.remove("ctrl-down");
      });

      document.getElementById("chat-container").addEventListener("click", function (e) {
        if (!(e.ctrlKey || e.metaKey)) return;

        let text = "";
        let target = null;

        const codeTarget = e.target.closest("pre") || e.target.closest("code");
        const mathTarget = e.target.closest(".katex");

        if (mathTarget) {
          target = mathTarget;
          const annotation = mathTarget.querySelector("annotation");
          if (annotation) {
            text = annotation.textContent;
          } else {
            text = mathTarget.querySelector(".katex-mathml math").getAttribute("alttext") || "";
          }
        } else if (codeTarget) {
          target = codeTarget;
          text = target.innerText;
        }

        if (!target || !text) return;

        e.preventDefault();
        navigator.clipboard.writeText(text).then(() => {
          const originalBg = target.style.backgroundColor;
          target.style.backgroundColor = "#ccc";
          setTimeout(() => {
            target.style.backgroundColor = originalBg;
          }, 100);
        });
      });

      // Boot this shit up
      init();
    </script>
  </body>
</html>
