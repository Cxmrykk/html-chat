<!doctype html>
<!--
=========================================================================================
RULES FOR CONTINUED EXISTENCE:
1. NO BULLSHIT FRAMEWORKS. If you think this needs React, you are the problem.
2. NO BUILD TOOLS. If it doesn't run by double-clicking the .html file, delete it.
3. DEPENDENCY HONESTY. We use Marked, KaTeX, and Prism because we aren't masochists.
   We value our time and sanity more than loading 100kb of minified JS.
4. SINGLE FILE SUPREMACY. If it can't live in this one file, it doesn't deserve to live.
5. PERFORMANCE IS A FEATURE. We don't animate. We don't fade. We don't "hydrate."
   We render the fucking HTML and we get out of the way.
=========================================================================================
-->
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <link
      rel="manifest"
      href='data:application/json,{"name":"HTML Chat","display":"standalone","icons":[{"src":"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTIwIDJINGMtMS4xIDAtMiAuOS0yIDJ2MThsNC00aDE0YzEuMSAwIDItLjkgMi0yVjRjMC0xLjEtLjktMi0yLTJ6Ii8+PC9zdmc+","sizes":"512x512","type":"image/svg+xml"}]}'
    />

    <title>HTML Chat</title>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css" />
    <script src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/auto-render.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/prismjs/themes/prism.min.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/prismjs/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"></script>

    <style>
      /* Just enough CSS to provide a functional interface */
      body {
        max-width: 1000px;
        margin: 0 auto;
        height: 100vh;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        font-family: monospace, sans-serif;
        line-height: 1.6;
        padding: 2rem 1rem 1rem 1rem;
        color: #111;
        background: #fafafa;
        overflow: hidden;
      }
      header {
        flex-shrink: 0;
      }
      h1,
      h2,
      h3 {
        margin-top: 0;
      }
      button {
        cursor: pointer;
        font-family: inherit;
        background: #eee;
        border: 1px solid #000;
        padding: 5px 10px;
        color: #000;
      }
      button:hover {
        background: #ccc;
      }
      input[type="text"],
      input[type="password"],
      textarea,
      select {
        font-family: inherit;
        padding: 8px;
        border: 1px solid #000;
        box-sizing: border-box;
        width: 100%;
        margin-bottom: 10px;
        background: #fff;
      }
      textarea {
        min-height: 100px;
        resize: vertical;
      }
      .hidden {
        display: none !important;
      }
      .top-actions {
        position: fixed;
        top: 1rem;
        right: 1rem;
        display: flex;
        gap: 15px;
        z-index: 100;
      }
      .top-btn {
        color: #0055ff;
        text-decoration: underline;
        cursor: pointer;
        font-size: 0.9em;
      }
      .top-btn:hover {
        color: #ff0055;
      }
      .grid {
        display: flex;
        gap: 2rem;
        flex-grow: 1;
        min-height: 0;
        margin-top: 1rem;
      }
      @media (max-width: 768px) {
        .sidebar:not(.hidden) + .main {
          display: none;
        }
        .sidebar,
        .main {
          min-width: 0;
        }
        .sidebar {
          padding-right: 0;
        }
      }
      .sidebar {
        flex: 1;
        min-width: 250px;
        overflow-y: auto;
        padding-right: 10px;
      }
      .main {
        flex: 3;
        min-width: 300px;
        display: flex;
        flex-direction: column;
        min-height: 0;
      }
      #chat-container {
        position: relative;
        flex-grow: 1;
        min-height: 0;
        overflow-y: auto;
        border: 2px solid #000;
        background: #ebebeb;
        padding: 15px;
        margin-bottom: 15px;
      }
      #input-area {
        flex-shrink: 0;
      }
      .msg {
        border-left: 4px solid #000;
        padding-left: 15px;
        margin-bottom: 20px;
        background: #fff;
        padding: 10px 10px 10px 15px;
        border-radius: 0 5px 5px 0;
        box-shadow: 2px 2px 0px #000;
      }
      .msg.editing {
        border-left-style: dashed;
        background: #f5f5f5;
      }
      .msg:last-child {
        margin-bottom: 0;
      }
      .msg.user {
        border-color: #0055ff;
      }
      .msg.assistant {
        border-color: #ff0055;
      }
      .msg.system {
        border-color: #ffaa00;
        background: #fff8e6;
      }
      .msg-meta {
        font-size: 0.85em;
        text-transform: uppercase;
        font-weight: bold;
        margin-bottom: 10px;
        color: #555;
        display: flex;
        justify-content: space-between;
      }
      .msg-actions button {
        font-size: 0.8em;
        padding: 2px 6px;
        margin-left: 5px;
      }
      .msg-content {
        overflow-wrap: anywhere;
      }
      .msg-content p:first-child {
        margin-top: 0;
      }
      .msg-content p:last-child {
        margin-bottom: 0;
      }
      .msg-content pre {
        padding: 10px;
        border: 1px solid #000;
        overflow-x: auto;
        overflow-y: hidden;
        max-height: none !important;
        border-radius: 0;
      }
      .msg-content code {
        background: #eee;
        padding: 2px 4px;
        color: #000;
      }
      .msg-content pre code {
        padding: 0;
        background: transparent;
        color: inherit;
      }
      .msg-content pre[class*="language-"] {
        background: #eee;
        margin: 0.5em 0;
        text-shadow: none;
      }
      .msg-content code[class*="language-"],
      .msg-content pre[class*="language-"] {
        font-family: inherit;
        font-size: 0.9em;
        line-height: 1.6;
        direction: ltr;
      }
      body.ctrl-down .msg-content pre[class*="language-"]:hover {
        background: #e0e0e0;
      }
      body.ctrl-down pre:hover code {
        background: transparent;
      }
      .chat-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 5px;
        border: 1px solid transparent;
        margin-bottom: 5px;
      }
      .chat-item.active {
        border-color: #000;
        background: #eee;
        font-weight: bold;
      }
      .chat-item-title {
        cursor: pointer;
        flex-grow: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        min-width: 0;
        margin-right: 10px;
      }
      .chat-item-actions {
        flex-shrink: 0;
        display: flex;
      }
      .chat-item-actions button {
        font-size: 0.7em;
        padding: 2px 5px;
        margin-left: 2px;
      }
      .config-box {
        background: #eee;
        padding: 15px;
        border: 1px solid #000;
        margin-bottom: 20px;
      }
      .checkbox-label {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 10px;
        cursor: pointer;
      }
      body.ctrl-down pre,
      body.ctrl-down code,
      body.ctrl-down .katex {
        cursor: pointer !important;
      }
      body.ctrl-down pre:hover,
      body.ctrl-down code:hover,
      body.ctrl-down .katex:hover,
      body.ctrl-down .chat-item:hover {
        background: #e0e0e0;
      }
      body.ctrl-down .chat-item-title {
        cursor: copy !important;
      }
      .katex {
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
      }
    </style>
  </head>
  <body>
    <div class="top-actions">
      <a id="toggle-title-btn" class="top-btn" title="Alt+O" onclick="toggleTitle()">[hide title]</a>
      <a id="toggle-sidebar-btn" class="top-btn" title="Alt+P" onclick="toggleSidebar()">[hide sidebar]</a>
    </div>

    <header id="header">
      <h1>HTML Chat</h1>
      <p>No 500MB Docker containers. No bullshit. Just you, your API key, and the fucking browser.</p>
    </header>

    <div class="grid">
      <aside class="sidebar" id="sidebar">
        <div class="config-box">
          <h3>Settings</h3>
          <label>Base URL</label>
          <input type="text" id="cfg-url" placeholder="https://api.openai.com/v1" />
          <label>API Key</label>
          <input type="password" id="cfg-key" placeholder="sk-..." />
          <label>Models (use commas)</label>
          <input type="text" id="cfg-models" placeholder="gpt-4o,gpt-3.5-turbo" />
          <label class="checkbox-label">
            <input type="checkbox" id="cfg-godmode" />
            <strong>Execute JavaScript</strong>
          </label>
          <button onclick="saveConfig()">Save Settings</button>
        </div>

        <div>
          <div style="display: flex; justify-content: space-between; align-items: center">
            <h3>Your Chats</h3>
            <button onclick="newChat()" title="Alt+T">+ New</button>
          </div>
          <div id="chat-list"></div>
        </div>
      </aside>

      <main class="main">
        <div id="chat-container"></div>
        <div id="input-area">
          <div style="display: flex; gap: 10px; margin-bottom: 10px">
            <select id="model-select" style="width: auto; margin: 0" onchange="saveLastModel()"></select>
            <button
              id="send-btn"
              onclick="sendMessage()"
              title="Ctrl+Enter / Cmd+Enter"
              style="flex-grow: 1; font-weight: bold"
            >
              Send
            </button>
            <button
              id="save-edit-btn"
              class="hidden"
              onclick="saveGlobalEdit()"
              title="Ctrl+Enter / Cmd+Enter"
              style="flex-grow: 1; font-weight: bold"
            >
              Save
            </button>
            <button
              id="cancel-edit-btn"
              class="hidden"
              onclick="cancelGlobalEdit()"
              style="flex-grow: 1; font-weight: bold"
            >
              Cancel
            </button>
          </div>
          <textarea id="chat-input" placeholder="Type your prompt here..."></textarea>
        </div>
      </main>
    </div>

    <script>
      // --- UTILS & STATE ---
      const $ = (s) => document.querySelector(s);
      const escapeHTML = (str) => (str || "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");

      let config = JSON.parse(localStorage.getItem("mf_config")) || {
        url: "https://api.openai.com/v1",
        key: "",
        models: "gpt-4o, gpt-4-turbo, gpt-3.5-turbo",
        godMode: false,
        lastModel: "",
      };
      let chats = JSON.parse(localStorage.getItem("mf_chats")) || [];
      let currentChatId = localStorage.getItem("mf_current_chat_id") || null;
      let currentAbortController = null;
      let isSidebarHidden =
        localStorage.getItem("mf_sidebar_hidden") === "true" || localStorage.getItem("mf_locked_in") === "true";
      let isTitleHidden = localStorage.getItem("mf_title_hidden") === "true";
      let editingMessageIndex = null;

      let promptHeight = localStorage.getItem("mf_prompt_height") || "";
      let editHeight = localStorage.getItem("mf_edit_height") || "250px";

      marked.use({
        extensions: [
          {
            name: "math",
            level: "inline",
            start(src) {
              return src.match(/\$/)?.index;
            },
            tokenizer(src) {
              const blockMatch = /^\$\$([\s\S]+?)\$\$/.exec(src);
              if (blockMatch) return { type: "math", raw: blockMatch[0], text: blockMatch[1] };
              const inlineMatch = /^\$([^\s$](?:\\.|[^$\n])*?)\$/.exec(src);
              if (inlineMatch) return { type: "math", raw: inlineMatch[0], text: inlineMatch[1] };
            },
            renderer(token) {
              return escapeHTML(token.raw);
            },
          },
        ],
      });

      function saveState() {
        localStorage.setItem("mf_config", JSON.stringify(config));
        localStorage.setItem("mf_chats", JSON.stringify(chats));
        localStorage.setItem("mf_current_chat_id", currentChatId || "");
        localStorage.setItem("mf_sidebar_hidden", isSidebarHidden);
        localStorage.setItem("mf_title_hidden", isTitleHidden);
      }

      // --- INITIALIZATION ---
      function init() {
        $("#cfg-url").value = config.url;
        $("#cfg-key").value = config.key;
        $("#cfg-models").value = config.models;
        $("#cfg-godmode").checked = config.godMode || false;
        updateModelDropdown();
        applySidebarState();
        applyTitleState();

        $("#chat-input").style.height = promptHeight;
        $("#chat-input").addEventListener("input", updateTokenCount);

        const textareaObserver = new ResizeObserver((entries) => {
          for (let entry of entries) {
            const h = entry.target.style.height;
            if (!h) continue;
            if (editingMessageIndex !== null) {
              editHeight = h;
              localStorage.setItem("mf_edit_height", h);
            } else {
              promptHeight = h;
              localStorage.setItem("mf_prompt_height", h);
            }
          }
        });
        textareaObserver.observe($("#chat-input"));

        if (!currentChatId && chats.length > 0) currentChatId = chats[0].id;
        renderApp();
      }

      function updateTokenCount() {
        const btn = $("#send-btn");
        if (!btn) return;

        // Don't overwrite state indicators
        if (btn.textContent.includes("Thinking") || btn.classList.contains("hidden")) return;

        const inputVal = $("#chat-input").value || "";
        let context = "";

        // Calculate context from the active chat data
        if (currentChatId) {
          const chat = chats.find((c) => c.id === currentChatId);
          if (chat && chat.messages) {
            context = chat.messages.map((m) => m.content).join(" ");
          }
        }

        // Napkin math: 1 token ~= 4 chars
        const totalChars = inputVal.length + context.length;
        const tokens = Math.ceil(totalChars / 4);

        // Logic: Hide if < 1k. Show k/M if > 1k. Remove .0
        if (tokens < 1000) {
          btn.textContent = "Send";
        } else {
          let label;
          if (tokens >= 1000000) {
            label = (tokens / 1000000).toFixed(1).replace(/\.0$/, "") + "M";
          } else {
            label = (tokens / 1000).toFixed(1).replace(/\.0$/, "") + "k";
          }
          btn.textContent = `Send (${label} tokens)`;
        }
      }

      function toggleSidebar() {
        isSidebarHidden = !isSidebarHidden;
        saveState();
        applySidebarState();
      }
      function applySidebarState() {
        $("#sidebar").classList.toggle("hidden", isSidebarHidden);
        $("#toggle-sidebar-btn").textContent = isSidebarHidden ? "[show sidebar]" : "[hide sidebar]";
      }

      function toggleTitle() {
        isTitleHidden = !isTitleHidden;
        saveState();
        applyTitleState();
      }
      function applyTitleState() {
        $("#header").classList.toggle("hidden", isTitleHidden);
        $("#toggle-title-btn").textContent = isTitleHidden ? "[show title]" : "[hide title]";
      }

      function saveConfig() {
        config = {
          ...config,
          url: $("#cfg-url").value.trim(),
          key: $("#cfg-key").value.trim(),
          models: $("#cfg-models").value.trim(),
          godMode: $("#cfg-godmode").checked,
        };
        saveState();
        updateModelDropdown();
        alert("Settings saved, don't fuck them up.");
      }

      function updateModelDropdown() {
        const select = $("#model-select");
        const models = config.models
          .split(",")
          .map((m) => m.trim())
          .filter(Boolean);
        select.innerHTML = models.map((m) => `<option value="${m}">${m}</option>`).join("");
        if (config.lastModel && models.includes(config.lastModel)) select.value = config.lastModel;
        else if (models.length > 0) {
          config.lastModel = models[0];
          saveState();
        }
      }
      function saveLastModel() {
        config.lastModel = $("#model-select").value;
        saveState();
      }

      // --- CHAT ACTIONS ---
      function newChat() {
        resetEditState();
        const id = Date.now().toString();
        chats.unshift({ id, title: "New Chat", messages: [] });
        currentChatId = id;
        if (window.innerWidth <= 768) {
          isSidebarHidden = true;
          applySidebarState();
        }
        saveState();
        renderApp();
      }

      function loadChat(id) {
        resetEditState();
        currentChatId = id;
        if (window.innerWidth <= 768) {
          isSidebarHidden = true;
          applySidebarState();
        }
        saveState();
        renderApp();
      }
      function deleteChat(id) {
        resetEditState();
        chats = chats.filter((c) => c.id !== id);
        if (currentChatId === id) currentChatId = chats.length ? chats[0].id : null;
        saveState();
        renderApp();
      }
      function renameChat(id) {
        const chat = chats.find((c) => c.id === id);
        const newTitle = prompt("Rename chat:", chat.title);
        if (newTitle) {
          chat.title = newTitle.trim();
          saveState();
          renderApp(true);
        }
      }
      function forkChat(msgIndex) {
        resetEditState();
        const chat = chats.find((c) => c.id === currentChatId);
        const newId = Date.now().toString();
        chats.unshift({
          id: newId,
          title: chat.title + " (Forked)",
          messages: JSON.parse(JSON.stringify(chat.messages.slice(0, msgIndex + 1))),
        });
        currentChatId = newId;
        saveState();
        renderApp();
      }
      function retryMessage(msgIndex) {
        resetEditState();
        const chat = chats.find((c) => c.id === currentChatId);
        $("#chat-input").value = chat.messages[msgIndex].content;
        chat.messages = chat.messages.slice(0, msgIndex);
        saveState();
        sendMessage();
      }
      function deleteMessage(msgIndex) {
        if (editingMessageIndex === msgIndex) resetEditState();
        else if (editingMessageIndex !== null && editingMessageIndex > msgIndex) {
          editingMessageIndex--;
        }
        chats.find((c) => c.id === currentChatId).messages.splice(msgIndex, 1);
        saveState();
        renderApp(true);
      }

      // --- EDITING ACTIONS ---
      function resetEditState() {
        editingMessageIndex = null;
        const sendBtn = $("#send-btn");
        const saveBtn = $("#save-edit-btn");
        const cancelBtn = $("#cancel-edit-btn");
        const area = $("#chat-input");

        if (sendBtn) sendBtn.classList.remove("hidden");
        if (saveBtn) saveBtn.classList.add("hidden");
        if (cancelBtn) cancelBtn.classList.add("hidden");

        if (area) {
          area.style.whiteSpace = "";
          area.style.overflowX = "";
          area.value = "";
          area.style.height = promptHeight;
        }
      }

      function startGlobalEdit(index) {
        editingMessageIndex = index;
        const chat = chats.find((c) => c.id === currentChatId);
        const area = $("#chat-input");
        area.value = chat.messages[index].content;
        area.style.height = editHeight;

        $("#send-btn").classList.add("hidden");
        $("#save-edit-btn").classList.remove("hidden");
        $("#cancel-edit-btn").classList.remove("hidden");

        renderApp(true);
        area.focus();
      }

      function saveGlobalEdit() {
        if (editingMessageIndex === null) return;
        const chat = chats.find((c) => c.id === currentChatId);
        chat.messages[editingMessageIndex].content = $("#chat-input").value;
        saveState();
        endGlobalEdit();
      }

      function cancelGlobalEdit() {
        endGlobalEdit();
      }

      function endGlobalEdit() {
        resetEditState();
        renderApp(true);
      }

      function toggleGlobalWrap() {
        const area = $("#chat-input");
        area.style.whiteSpace = area.style.whiteSpace === "pre" ? "pre-wrap" : "pre";
        area.style.overflowX = area.style.whiteSpace === "pre" ? "auto" : "hidden";
      }

      // --- RENDERING (Template Literals > DOM Building) ---
      function renderApp(preserveScroll = false) {
        renderChatList();
        renderCurrentChat(preserveScroll);
      }

      function renderChatList() {
        const list = $("#chat-list");
        if (!chats.length)
          return (list.innerHTML = '<p style="font-size:0.8em; color:#666;">No chats. Start a new one, asshole.</p>');

        list.innerHTML = chats
          .map(
            (chat) => `
          <div class="chat-item ${chat.id === currentChatId ? "active" : ""}" data-id="${chat.id}">
            <div class="chat-item-title" data-action="load">${escapeHTML(chat.title)}</div>
            <div class="chat-item-actions">
              <button data-action="rename" title="Rename">r</button>
              <button data-action="delete" title="Delete">d</button>
            </div>
          </div>
        `,
          )
          .join("");
      }

      function renderCurrentChat(preserveScroll = false) {
        const container = $("#chat-container");
        const prevScroll = container.scrollTop;

        if (!currentChatId) return (container.innerHTML = '<h3 style="margin:0;">No chat selected.</h3>');
        const chat = chats.find((c) => c.id === currentChatId);
        if (!chat.messages.length)
          return (container.innerHTML = '<p style="margin:0;">It is fucking empty in here. Send a prompt.</p>');

        container.innerHTML = chat.messages
          .map(
            (msg, i) => `
          <div class="msg ${msg.role} ${editingMessageIndex === i ? "editing" : ""}" data-index="${i}">
            <div class="msg-meta">
              <span>${msg.role}</span>
              <div class="msg-actions">
                ${
                  editingMessageIndex === i
                    ? `<button data-action="save-edit">Save</button>
                       <button data-action="cancel-edit">Cancel</button>
                       <button data-action="toggle-wrap">Toggle Wrap</button>`
                    : `<button data-action="edit">Edit</button>
                       <button data-action="fork">Fork</button>
                       ${msg.role === "user" ? `<button data-action="retry">Retry</button>` : ""}
                       <button data-action="delete">Delete</button>`
                }
              </div>
            </div>
            <div class="msg-content">${marked.parse(msg.content || "")}</div>
          </div>
        `,
          )
          .join("");

        renderMathInElement(container, {
          delimiters: [
            { left: "$$", right: "$$", display: true },
            { left: "$", right: "$", display: false },
          ],
          output: "htmlAndMathml",
          throwOnError: false,
        });
        Prism.highlightAllUnder(container);

        if (preserveScroll) container.scrollTop = prevScroll;
        else {
          const lastMsg = container.lastElementChild;
          if (lastMsg)
            container.scrollTop = lastMsg.classList.contains("user") ? container.scrollHeight : lastMsg.offsetTop - 15;
        }

        updateTokenCount();
      }

      // --- EVENT DELEGATION ---
      $("#chat-list").addEventListener("click", (e) => {
        const item = e.target.closest(".chat-item");
        if (!item) return;
        const id = item.dataset.id;
        const action = e.target.dataset.action;

        if (action === "rename") renameChat(id);
        else if (action === "delete") deleteChat(id);
        else if (action === "load") {
          if (e.ctrlKey || e.metaKey) {
            const chat = chats.find((c) => c.id === id);
            const text =
              `# ${chat.title}\n\n` + chat.messages.map((m) => `## ${m.role.toUpperCase()}\n${m.content}\n\n`).join("");
            navigator.clipboard.writeText(text.trim()).then(() => {
              item.style.background = "#ccc";
              setTimeout(() => (item.style.background = ""), 150);
            });
          } else loadChat(id);
        }
      });

      $("#chat-container").addEventListener("click", (e) => {
        const btn = e.target.closest("button[data-action]");
        if (!btn) return;
        const msgDiv = btn.closest(".msg");
        const index = parseInt(msgDiv.dataset.index, 10);
        const action = btn.dataset.action;

        if (action === "edit") startGlobalEdit(index);
        else if (action === "save-edit") saveGlobalEdit();
        else if (action === "cancel-edit") cancelGlobalEdit();
        else if (action === "toggle-wrap") toggleGlobalWrap();
        else if (action === "fork") forkChat(index);
        else if (action === "retry") retryMessage(index);
        else if (action === "delete") deleteMessage(index);
      });

      // --- API & GOD MODE ---
      async function executeGodMode(code) {
        let logs = [];
        const safeStr = (obj) => {
          try {
            return typeof obj === "object" ? JSON.stringify(obj, null, 2) : String(obj);
          } catch {
            return Object.prototype.toString.call(obj);
          }
        };
        const proxyConsole = {
          log: (...args) => logs.push(args.map(safeStr).join(" ")),
          error: (...args) => logs.push("ERROR: " + args.map(safeStr).join(" ")),
        };
        let result,
          errorStr = "";
        try {
          const execFn = new (Object.getPrototypeOf(async function () {}).constructor)("console", code);
          result = await execFn(proxyConsole);
        } catch (err) {
          errorStr = err.toString();
        }

        let out = "**Execution Result:**\n```text\n";
        if (logs.length) out += logs.join("\n") + "\n";
        if (result !== undefined) out += "Return: " + safeStr(result) + "\n";
        if (errorStr) out += "Error: " + errorStr + "\n";
        if (!logs.length && result === undefined && !errorStr) out += "Code executed successfully with no output.\n";
        return out + "```";
      }

      async function sendMessage(autoLoopDepth = 0) {
        const btn = $("#send-btn");
        const MAX_LOOPS = 5;

        if (autoLoopDepth >= MAX_LOOPS) {
          chats
            .find((c) => c.id === currentChatId)
            .messages.push({
              role: "system",
              content: `**System Error:** Maximum execution loop depth (${MAX_LOOPS}) reached.`,
            });
          updateTokenCount();
          saveState();
          renderApp();
          return;
        }

        const isAutoLoop = autoLoopDepth > 0;
        if (currentAbortController && !isAutoLoop) {
          currentAbortController.abort();
          currentAbortController = null;
          btn.textContent = "Send";
          return;
        }

        const inputEl = $("#chat-input");
        const text = inputEl.value.trim();

        if (!isAutoLoop) {
          if (!text) return;
          if (!config.key) return alert("Please enter your API key in the settings first.");
          if (!currentChatId) newChat();
        }

        const chat = chats.find((c) => c.id === currentChatId);

        if (!isAutoLoop) {
          if (!chat.messages.length) {
            const lastDoubleNewline = text.lastIndexOf("\n\n");
            const titleSource = lastDoubleNewline !== -1 ? text.substring(lastDoubleNewline + 2).trim() : text;
            chat.title = titleSource.substring(0, 30) + (titleSource.length > 30 ? "..." : "");
          }
          chat.messages.push({ role: "user", content: text });
          inputEl.value = "";
          saveState();
          renderApp();
        }

        currentAbortController = new AbortController();
        btn.textContent = isAutoLoop ? `Thinking (Loop ${autoLoopDepth}/${MAX_LOOPS})...` : "Thinking...";

        try {
          const cleanMessages = chat.messages
            .filter(
              (m) =>
                m.role !== "system" ||
                m.content.includes("**Executing Code:**") ||
                m.content.includes("**Execution Result:**"),
            )
            .map((m) => ({
              role:
                m.role === "system" && (m.content.includes("**Executing") || m.content.includes("**Execution"))
                  ? "user"
                  : m.role,
              content: m.content || "",
            }));

          if (config.godMode) {
            cleanMessages.unshift({
              role: "system",
              content:
                "[SYSTEM OVERRIDE: CODE EXECUTION ENABLED]\nYou are executing directly inside the user's web browser (JS console). You are NOT in a sandboxed cloud environment. You are NOT in Node.js or Python. You have full, unrestricted access to the user's 'window', 'document', 'navigator', 'localStorage', etc.\n\nHowever, to execute code, you MUST use this exact syntax (the return value is sent back to you):\n<run>\n// browser-side JS goes here\nreturn data.toString();\n</run>\n\nCRITICAL RULES FOR TOOL USE:\n1. DO NOT CALCULATE MANUALLY. If the user asks a math, logic, or data question, you MUST use a <run> block to compute it. Do not trust your own internal math.\n2. NO FAKE CODE, MOCKS, OR HARDCODING. Your JavaScript MUST contain actual logic, algorithms, math, or simulations. DO NOT write \"simplified\" checks or hardcode the answer you already suspect. If you need to search for a counterexample, write a GENUINE exhaustive search. The code itself must do the actual work to prove the answer.\n3. VANILLA JS LIMITATIONS. You are in a browser. You do not have Python's `itertools`, `numpy`, or `scipy`. If you need combinations, permutations, matrix operations, or deep equality checks, you MUST implement them yourself.\n4. STATE PERSISTENCE. Each <run> block executes in a fresh async function scope. Variables declared with `let` or `const` will NOT persist between runs. To save state across multiple runs, attach it to the global `window` object (e.g., `window.myState = ...`).\n5. ITERATIVE PROBLEM SOLVING. If a problem is too complex for one script, break it down. Write a <run> block to generate data, save it to `window`, and then write a second <run> block to process it. \n6. DEFER YOUR ANSWER. If you output a <run> block, DO NOT attempt to answer the user's prompt in the same message. Output ONLY your thought process and the <run> block.\n7. WAIT FOR THE RESULT. The system will execute your code and return the result in the next message. If your code throws an error, DO NOT apologizeâ€”just write another <run> block to fix it and try again.\n8. DELIVER THE FINAL ANSWER ONLY AFTER EXECUTION. Unless an error is spotted, once you have the results write your final response to the user and DO NOT include any <run> tags.\n9. NEVER use Node.js modules (require, os, fs). They do not exist here.\n10. NEVER use markdown backticks (```) around the <run> tags. Just output the raw tags.\n\nEXAMPLE WORKFLOW:\nUser: What is the square root of 9999?\nAssistant: I need to compute this using JavaScript.\n<run>\nreturn Math.sqrt(9999);\n</run>\nUser: **Execution Result:**\n```text\nReturn: 99.99499987499375\n```\nAssistant: The square root of 9999 is 99.994999875.",
            });
          }

          const response = await fetch(`${config.url}/chat/completions`, {
            method: "POST",
            headers: { "Content-Type": "application/json", Authorization: `Bearer ${config.key}` },
            body: JSON.stringify({ model: $("#model-select").value, messages: cleanMessages }),
            signal: currentAbortController.signal,
          });

          if (!response.ok)
            throw new Error((await response.json().catch(() => ({}))).error?.message || `HTTP ${response.status}`);
          const reply = (await response.json()).choices[0].message.content || "";

          if (config.godMode && reply) {
            const runMatches = [...reply.matchAll(/<run>([\s\S]*?)<\/run>/g)];
            if (runMatches.length > 0) {
              chat.messages.push({
                role: "assistant",
                content: reply.replace(/<run>[\s\S]*?<\/run>/g, "").trim() || "*(Executing code...)*",
              });
              saveState();
              renderApp();

              for (const match of runMatches) {
                const code = match[1].trim();
                chat.messages.push({
                  role: "system",
                  content: `**Executing Code:**\n\`\`\`javascript\n${code}\n\`\`\``,
                });
                saveState();
                renderApp();

                // We change the role to "system" for the UI
                chat.messages.push({ role: "system", content: await executeGodMode(code) });
                saveState();
                renderApp();
              }
              return sendMessage(autoLoopDepth + 1);
            }
          }

          if (reply.trim() !== "" || isAutoLoop) {
            chat.messages.push({ role: "assistant", content: reply });
            saveState();
            renderApp();
          }
        } catch (error) {
          chat.messages.push({
            role: "system",
            content:
              error.name === "AbortError" ? "**System:** Request cancelled by user." : `**Error:**\n\n${error.message}`,
          });
        }

        currentAbortController = null;
        btn.textContent = "Send";
        saveState();
        renderApp();
      }

      // --- KEYBOARD & CLIPBOARD ---
      $("#chat-input").addEventListener("keydown", (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === "Enter") {
          if (editingMessageIndex !== null) saveGlobalEdit();
          else sendMessage();
        }
      });

      document.addEventListener("keydown", (e) => {
        if (e.altKey && e.key.toLowerCase() === "t") {
          e.preventDefault();
          newChat();
          $("#chat-input").focus();
        }
        if (e.altKey && e.key.toLowerCase() === "w") {
          e.preventDefault();
          if (currentChatId) deleteChat(currentChatId);
        }
        if (e.altKey && e.key.toLowerCase() === "r") {
          e.preventDefault();
          renameChat(currentChatId);
        }
        if (e.altKey && e.key.toLowerCase() === "p") {
          e.preventDefault();
          toggleSidebar();
        }
        if (e.altKey && e.key.toLowerCase() === "o") {
          e.preventDefault();
          toggleTitle();
        }

        if (e.shiftKey && (e.key === "ArrowUp" || e.key === "ArrowDown")) {
          if (document.activeElement?.tagName === "TEXTAREA") return;
          e.preventDefault();
          const container = $("#chat-container");
          const msgs = Array.from(container.querySelectorAll(".msg"));
          if (!msgs.length) return;

          if (e.key === "ArrowDown") {
            const next = msgs.find((m) => m.offsetTop - 15 > container.scrollTop + 5);
            container.scrollTop = next ? next.offsetTop - 15 : container.scrollHeight;
          } else {
            const prev = msgs
              .slice()
              .reverse()
              .find((m) => m.offsetTop - 15 < container.scrollTop - 5);
            container.scrollTop = prev ? prev.offsetTop - 15 : 0;
          }
        }

        if (e.altKey && (e.key === "ArrowUp" || e.key === "ArrowDown")) {
          e.preventDefault();
          if (!chats.length) return;
          let idx = Math.max(
            0,
            chats.findIndex((c) => c.id === currentChatId),
          );
          if (e.key === "ArrowUp" && idx > 0) loadChat(chats[idx - 1].id);
          if (e.key === "ArrowDown" && idx < chats.length - 1) loadChat(chats[idx + 1].id);
        }

        if (!e.shiftKey && !e.altKey && !e.ctrlKey && !e.metaKey && (e.key === "ArrowUp" || e.key === "ArrowDown")) {
          const tag = document.activeElement?.tagName.toLowerCase();
          if (tag !== "input" && tag !== "textarea" && tag !== "select") {
            e.preventDefault();
            $("#chat-container").scrollBy({ top: e.key === "ArrowDown" ? 150 : -150, behavior: "smooth" });
          }
        }
      });

      const toggleCopyMode = (e) => {
        if (e.key === "Control" || e.key === "Meta") document.body.classList.toggle("ctrl-down", e.type === "keydown");
      };
      window.addEventListener("keydown", toggleCopyMode);
      window.addEventListener("keyup", toggleCopyMode);
      window.addEventListener("blur", () => document.body.classList.remove("ctrl-down"));

      $("#chat-container").addEventListener("click", (e) => {
        if (!(e.ctrlKey || e.metaKey)) return;
        const target = e.target.closest(".katex") || e.target.closest("pre") || e.target.closest("code");
        if (!target) return;

        let text = target.classList.contains("katex")
          ? target.querySelector("annotation")?.textContent ||
            target.querySelector(".katex-mathml math")?.getAttribute("alttext") ||
            ""
          : target.innerText;

        if (text) {
          e.preventDefault();
          navigator.clipboard.writeText(text).then(() => {
            const bg = target.style.backgroundColor;
            target.style.backgroundColor = "#ccc";
            setTimeout(() => (target.style.backgroundColor = bg), 100);
          });
        }
      });

      init();
    </script>
  </body>
</html>
