<!doctype html>
<!--
=========================================================================================
RULES FOR CONTINUED EXISTENCE:
1. NO BULLSHIT FRAMEWORKS. If you think this needs React, you are the problem.
2. NO BUILD TOOLS. If it doesn't run by double-clicking the .html file, delete it.
3. DEPENDENCY HONESTY. We use Marked, KaTeX, and Prism because we aren't masochists.
   We value our time and sanity more than loading 100kb of minified JS.
4. SINGLE FILE SUPREMACY. If it can't live in this one file, it doesn't deserve to live.
5. PERFORMANCE IS A FEATURE. We don't animate. We don't fade. We don't "hydrate."
   We render the fucking HTML and we get out of the way.

"A designer knows he has achieved perfection not when there is nothing left to add, 
but when there is nothing left to take away." — Some dead guy.
=========================================================================================
-->
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>HTML Chat</title>

    <!-- Yeah, I'm loading a 30kb script for Markdown. Writing a regex parser for this shit is a waste of time. Deal with it. -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <!-- The math shit. Unless you like reading raw latex, we're gonna need this too. -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css" />
    <script src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/auto-render.min.js"></script>

    <!-- I'd rather neck myself than stare at a gray wall of text. -->
    <link href="https://cdn.jsdelivr.net/npm/prismjs/themes/prism.min.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/prismjs/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"></script>

    <style>
      /* Just enough CSS so it doesn't look like shit. */
      body {
        max-width: 1000px;
        margin: 0 auto;
        height: 100vh;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        font-family: monospace, sans-serif;
        line-height: 1.6;
        padding: 2rem 1rem 1rem 1rem;
        color: #111;
        background: #fafafa;
        overflow: hidden; /* NO BODY SCROLLING. EVER. */
      }

      header {
        flex-shrink: 0; /* Prevents the header from getting squished */
      }

      h1,
      h2,
      h3 {
        margin-top: 0;
      }
      button {
        cursor: pointer;
        font-family: inherit;
        background: #eee;
        border: 1px solid #000;
        padding: 5px 10px;
        color: #000;
      }
      button:hover {
        background: #ccc;
      }
      input,
      textarea,
      select {
        font-family: inherit;
        padding: 8px;
        border: 1px solid #000;
        box-sizing: border-box;
        width: 100%;
        margin-bottom: 10px;
        background: #fff;
      }
      textarea {
        min-height: 100px;
        resize: vertical;
      }
      .hidden {
        display: none !important;
      }

      /* Top Actions */
      .top-actions {
        position: fixed;
        top: 1rem;
        right: 1rem;
        display: flex;
        gap: 15px;
        z-index: 100;
      }
      .top-btn {
        color: #0055ff;
        text-decoration: underline;
        cursor: pointer;
        font-size: 0.9em;
      }
      .top-btn:hover {
        color: #ff0055;
      }

      /* Layout */
      .grid {
        display: flex;
        gap: 2rem;
        flex-grow: 1;
        min-height: 0; /* Forces flexbox to respect boundaries */
        margin-top: 1rem;
        /* Removed flex-wrap so it doesn't stack and break the 100vh limit */
      }

      /* Basic mobile support so it doesn't look like shit on a phone */
      @media (max-width: 768px) {
        .grid {
          flex-direction: column;
        }
        .sidebar {
          flex: 0 0 30%;
          min-height: 0;
        }
      }

      /* Sidebar with its own fucking scroll context */
      .sidebar {
        flex: 1;
        min-width: 250px;
        overflow-y: auto;
        padding-right: 10px;
      }

      .main {
        flex: 3;
        min-width: 300px;
        display: flex;
        flex-direction: column;
        min-height: 0;
      }

      /* Chat Container */
      #chat-container {
        position: relative;
        flex-grow: 1;
        min-height: 0; /* Let it actually shrink */
        overflow-y: auto;
        border: 2px solid #000;
        background: #ebebeb;
        padding: 15px;
        margin-bottom: 15px;
      }

      #input-area {
        flex-shrink: 0; /* Prevents the text area from being crushed by the chat container */
      }

      /* Chat Messages */
      .msg {
        border-left: 4px solid #000;
        padding-left: 15px;
        margin-bottom: 20px;
        background: #fff;
        padding-top: 10px;
        padding-bottom: 10px;
        padding-right: 10px;
        border-radius: 0 5px 5px 0;
        box-shadow: 2px 2px 0px #000;
      }
      .msg:last-child {
        margin-bottom: 0;
      }
      .msg.user {
        border-color: #0055ff;
      }
      .msg.assistant {
        border-color: #ff0055;
      }
      .msg.system {
        border-color: #ffaa00;
        background: #fff8e6;
      }

      .msg-meta {
        font-size: 0.85em;
        text-transform: uppercase;
        font-weight: bold;
        margin-bottom: 10px;
        color: #555;
        display: flex;
        justify-content: space-between;
      }
      .msg-actions button {
        font-size: 0.8em;
        padding: 2px 6px;
        margin-left: 5px;
      }
      .msg-content {
        overflow-x: auto;
      }
      .msg-content p:first-child {
        margin-top: 0;
      }
      .msg-content p:last-child {
        margin-bottom: 0;
      }

      /* Markdown Code Blocks */
      .msg-content pre {
        padding: 10px;
        border: 1px solid #000;
        overflow-x: auto;
        border-radius: 0;
      }
      .msg-content code {
        background: #eee;
        padding: 2px 4px;
        color: #000;
      }
      .msg-content pre code {
        padding: 0;
        background: transparent;
        color: inherit;
      }

      /* Override Prism's soft bullshit without breaking hover states */
      .msg-content pre[class*="language-"] {
        background: #eee;
        margin: 0.5em 0;
        text-shadow: none;
      }
      .msg-content code[class*="language-"],
      .msg-content pre[class*="language-"] {
        font-family: inherit;
        font-size: 0.9em;
        line-height: 1.6;
        direction: ltr;
      }

      /* Highlight the whole block on Ctrl-Copy hover */
      body.ctrl-down .msg-content pre[class*="language-"]:hover {
        background: #e0e0e0;
      }
      body.ctrl-down pre:hover code {
        background: transparent; /* Stop the text from highlighting independently */
      }

      /* Edit Area */
      .edit-area {
        min-height: 250px;
      }

      /* Chat List */
      .chat-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 5px;
        border: 1px solid transparent;
        margin-bottom: 5px;
      }
      .chat-item.active {
        border-color: #000;
        background: #eee;
        font-weight: bold;
      }
      .chat-item-title {
        cursor: pointer;
        flex-grow: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        min-width: 0;
        margin-right: 10px;
      }
      .chat-item-actions {
        flex-shrink: 0;
        display: flex;
      }
      .chat-item-actions button {
        font-size: 0.7em;
        padding: 2px 5px;
        margin-left: 2px;
      }

      /* Config */
      .config-box {
        background: #eee;
        padding: 15px;
        border: 1px solid #000;
        margin-bottom: 20px;
      }

      body.ctrl-down pre,
      body.ctrl-down code,
      body.ctrl-down .katex {
        cursor: pointer !important;
      }

      /* CTRL-Copy */
      body.ctrl-down pre:hover,
      body.ctrl-down code:hover,
      body.ctrl-down .katex:hover {
        background: #e0e0e0;
      }

      /* Latex */
      .katex {
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
      }
    </style>
  </head>
  <body>
    <div class="top-actions">
      <a id="toggle-title-btn" class="top-btn" title="Alt+O" onclick="toggleTitle()">[hide title]</a>
      <a id="toggle-sidebar-btn" class="top-btn" title="Alt+P" onclick="toggleSidebar()">[hide sidebar]</a>
    </div>

    <header>
      <h1>HTML Chat</h1>
      <p>No 500MB Docker containers. No bullshit. Just you, your API key, and the fucking browser.</p>
    </header>

    <div class="grid">
      <!-- SIDEBAR: Config & Chat List -->
      <aside class="sidebar" id="sidebar">
        <div class="config-box">
          <h3>Settings</h3>
          <label>Base URL</label>
          <input type="text" id="cfg-url" placeholder="https://api.openai.com/v1" />

          <label>API Key (Saved in your browser)</label>
          <input type="password" id="cfg-key" placeholder="sk-..." />

          <label>Models (Comma separated)</label>
          <input type="text" id="cfg-models" placeholder="gpt-4o, gpt-3.5-turbo" />

          <button onclick="saveConfig()">Save Settings</button>
        </div>

        <div>
          <div style="display: flex; justify-content: space-between; align-items: center">
            <h3>Your Chats</h3>
            <button onclick="newChat()" title="Alt+T">+ New</button>
          </div>
          <div id="chat-list"></div>
        </div>
      </aside>

      <!-- MAIN: Chat Area -->
      <main class="main">
        <div id="chat-container">
          <!-- Messages go here -->
        </div>

        <div id="input-area">
          <div style="display: flex; gap: 10px; margin-bottom: 10px">
            <select id="model-select" style="width: auto; margin: 0"></select>
            <button
              id="send-btn"
              onclick="sendMessage()"
              title="Ctrl+Enter / Cmd+Enter"
              style="flex-grow: 1; font-weight: bold"
            >
              Send
            </button>
          </div>
          <textarea id="chat-input" placeholder="Type your prompt here..."></textarea>
        </div>
      </main>
    </div>

    <script>
      // --- STATE MANAGEMENT ---
      let config = JSON.parse(localStorage.getItem("mf_config")) || {
        url: "https://api.openai.com/v1",
        key: "",
        models: "gpt-4o, gpt-4-turbo, gpt-3.5-turbo",
      };
      let chats = JSON.parse(localStorage.getItem("mf_chats")) || [];
      let currentChatId = localStorage.getItem("mf_current_chat_id") || null;

      // Fallback to 'mf_locked_in' so your old state doesn't break
      let isSidebarHidden =
        localStorage.getItem("mf_sidebar_hidden") === "true" || localStorage.getItem("mf_locked_in") === "true";
      let isTitleHidden = localStorage.getItem("mf_title_hidden") === "true";

      function saveState() {
        localStorage.setItem("mf_config", JSON.stringify(config));
        localStorage.setItem("mf_chats", JSON.stringify(chats));
        localStorage.setItem("mf_current_chat_id", currentChatId || "");
        localStorage.setItem("mf_sidebar_hidden", isSidebarHidden);
        localStorage.setItem("mf_title_hidden", isTitleHidden);
      }

      // --- INITIALIZATION ---
      function init() {
        document.getElementById("cfg-url").value = config.url;
        document.getElementById("cfg-key").value = config.key;
        document.getElementById("cfg-models").value = config.models;

        updateModelDropdown();
        applySidebarState();
        applyTitleState();

        if (!currentChatId && chats.length > 0) {
          currentChatId = chats[0].id;
        }

        renderApp();
      }

      function toggleSidebar() {
        isSidebarHidden = !isSidebarHidden;
        saveState();
        applySidebarState();
      }

      function applySidebarState() {
        const sidebar = document.getElementById("sidebar");
        const btn = document.getElementById("toggle-sidebar-btn");
        if (isSidebarHidden) {
          sidebar.classList.add("hidden");
          btn.textContent = "[show sidebar]";
        } else {
          sidebar.classList.remove("hidden");
          btn.textContent = "[hide sidebar]";
        }
      }

      function toggleTitle() {
        isTitleHidden = !isTitleHidden;
        saveState();
        applyTitleState();
      }

      function applyTitleState() {
        const header = document.querySelector("header");
        const btn = document.getElementById("toggle-title-btn");
        if (isTitleHidden) {
          header.classList.add("hidden");
          btn.textContent = "[show title]";
        } else {
          header.classList.remove("hidden");
          btn.textContent = "[hide title]";
        }
      }

      function saveConfig() {
        config.url = document.getElementById("cfg-url").value.trim();
        config.key = document.getElementById("cfg-key").value.trim();
        config.models = document.getElementById("cfg-models").value.trim();
        saveState();
        updateModelDropdown();
        alert("Settings saved, don't fuck them up.");
      }

      function updateModelDropdown() {
        const select = document.getElementById("model-select");
        select.innerHTML = "";
        const models = config.models
          .split(",")
          .map((m) => m.trim())
          .filter((m) => m);
        models.forEach((m) => {
          const opt = document.createElement("option");
          opt.value = m;
          opt.textContent = m;
          select.appendChild(opt);
        });
      }

      // --- CHAT MANAGEMENT ---
      function newChat() {
        const id = Date.now().toString();
        chats.unshift({ id, title: "New Chat", messages: [] });
        currentChatId = id;
        saveState();
        renderApp();
      }

      function loadChat(id) {
        currentChatId = id;
        saveState();
        renderApp();
      }

      function deleteChat(id) {
        chats = chats.filter((c) => c.id !== id);
        if (currentChatId === id) currentChatId = chats.length ? chats[0].id : null;
        saveState();
        renderApp();
      }

      function renameChat(id) {
        const chat = chats.find((c) => c.id === id);
        const newTitle = prompt("Rename chat:", chat.title);
        if (newTitle) {
          chat.title = newTitle.trim();
          saveState();
          renderApp(true); // Preserve scroll just in case
        }
      }

      function forkChat(msgIndex) {
        const chat = chats.find((c) => c.id === currentChatId);
        const newId = Date.now().toString();
        const forkedMessages = JSON.parse(JSON.stringify(chat.messages.slice(0, msgIndex + 1)));

        chats.unshift({
          id: newId,
          title: chat.title + " (Forked)",
          messages: forkedMessages,
        });

        currentChatId = newId;
        saveState();
        renderApp();
      }

      function retryMessage(msgIndex) {
        const chat = chats.find((c) => c.id === currentChatId);
        const textToRetry = chat.messages[msgIndex].content;

        // Truncate chat up to the target index (exclusive)
        chat.messages = chat.messages.slice(0, msgIndex);
        saveState();

        // Put text in input and send that shit again
        document.getElementById("chat-input").value = textToRetry;
        sendMessage();
      }

      function deleteMessage(msgIndex) {
        const chat = chats.find((c) => c.id === currentChatId);
        chat.messages.splice(msgIndex, 1);
        saveState();
        renderApp(true); // Preserve scroll position
      }

      // --- RENDERING ---
      function renderApp(preserveScroll = false) {
        renderChatList();
        renderCurrentChat(preserveScroll);
      }

      function renderChatList() {
        const list = document.getElementById("chat-list");
        list.innerHTML = "";

        if (chats.length === 0) {
          list.innerHTML = '<p style="font-size:0.8em; color:#666;">No chats. Start a new one, asshole.</p>';
          return;
        }

        chats.forEach((chat) => {
          const div = document.createElement("div");
          div.className = `chat-item ${chat.id === currentChatId ? "active" : ""}`;

          const title = document.createElement("div");
          title.className = "chat-item-title";
          title.textContent = chat.title;
          title.onclick = () => loadChat(chat.id);

          const actions = document.createElement("div");
          actions.className = "chat-item-actions";

          const renBtn = document.createElement("button");
          renBtn.textContent = "✎";
          renBtn.title = chat.id === currentChatId ? "Rename (Alt+R)" : "Rename";
          renBtn.onclick = () => renameChat(chat.id);

          const delBtn = document.createElement("button");
          delBtn.textContent = "×";
          delBtn.title = chat.id === currentChatId ? "Delete (Alt+W)" : "Delete";
          delBtn.onclick = () => {
            if (confirm("Are you sure you want to nuke this chat?")) {
              deleteChat(chat.id);
            }
          };

          actions.appendChild(renBtn);
          actions.appendChild(delBtn);

          div.appendChild(title);
          div.appendChild(actions);
          list.appendChild(div);
        });
      }

      function renderCurrentChat(preserveScroll = false) {
        const container = document.getElementById("chat-container");
        const prevScroll = container.scrollTop;

        container.innerHTML = "";

        if (!currentChatId) {
          container.innerHTML = '<h3 style="margin:0;">No chat selected.</h3>';
          return;
        }

        const chat = chats.find((c) => c.id === currentChatId);
        if (chat.messages.length === 0) {
          container.innerHTML = '<p style="margin:0;">It is fucking empty in here. Send a prompt.</p>';
          return;
        }

        chat.messages.forEach((msg, index) => {
          const msgDiv = document.createElement("div");
          msgDiv.className = `msg ${msg.role}`;

          // Meta header
          const metaDiv = document.createElement("div");
          metaDiv.className = "msg-meta";

          const roleSpan = document.createElement("span");
          roleSpan.textContent = msg.role;

          const actionsDiv = document.createElement("div");
          actionsDiv.className = "msg-actions";

          const editBtn = document.createElement("button");
          editBtn.textContent = "Edit";

          const forkBtn = document.createElement("button");
          forkBtn.textContent = "Fork";
          forkBtn.onclick = () => forkChat(index);

          actionsDiv.appendChild(editBtn);
          actionsDiv.appendChild(forkBtn);

          // Only add Retry button if it's a user message
          if (msg.role === "user") {
            const retryBtn = document.createElement("button");
            retryBtn.textContent = "Retry";
            retryBtn.onclick = () => retryMessage(index);
            actionsDiv.appendChild(retryBtn);
          }

          const delBtn = document.createElement("button");
          delBtn.textContent = "Delete";
          delBtn.onclick = () => deleteMessage(index);

          actionsDiv.appendChild(delBtn);

          metaDiv.appendChild(roleSpan);
          metaDiv.appendChild(actionsDiv);

          // Content area
          const contentDiv = document.createElement("div");
          contentDiv.className = "msg-content";

          // We double-escape backslashes inside $$ blocks so marked.js doesn't fuck them up
          const escapedContent = msg.content.replace(/(\${1,2})([\s\S]*?)\1/g, (match) => {
            return match.replace(/\\/g, "\\\\");
          });

          contentDiv.innerHTML = marked.parse(escapedContent);

          // Edit area (hidden by default)
          const editArea = document.createElement("textarea");
          editArea.className = "hidden edit-area";
          editArea.value = msg.content;

          // Edit Actions Container
          const editActionsContainer = document.createElement("div");
          editActionsContainer.className = "hidden";
          editActionsContainer.style.marginTop = "5px";

          const saveEditBtn = document.createElement("button");
          saveEditBtn.textContent = "Save";

          const cancelEditBtn = document.createElement("button");
          cancelEditBtn.textContent = "Cancel";
          cancelEditBtn.style.marginLeft = "5px";

          const toggleWrapBtn = document.createElement("button");
          toggleWrapBtn.textContent = "Toggle Wrap";
          toggleWrapBtn.style.marginLeft = "5px";

          // Toggle wrap logic
          toggleWrapBtn.onclick = () => {
            editArea.style.whiteSpace = editArea.style.whiteSpace === "pre" ? "pre-wrap" : "pre";
            editArea.style.overflowX = editArea.style.whiteSpace === "pre" ? "auto" : "hidden";
          };

          editActionsContainer.appendChild(saveEditBtn);
          editActionsContainer.appendChild(cancelEditBtn);
          editActionsContainer.appendChild(toggleWrapBtn);

          // Edit logic
          editBtn.onclick = () => {
            contentDiv.classList.add("hidden");
            editArea.classList.remove("hidden");
            editActionsContainer.classList.remove("hidden");
            editBtn.classList.add("hidden");
            editArea.focus();
          };

          cancelEditBtn.onclick = () => {
            renderApp(true); // Just re-render to get rid of the edit state
          };

          saveEditBtn.onclick = () => {
            msg.content = editArea.value;
            saveState();
            renderApp(true); // Save and refresh
          };

          msgDiv.appendChild(metaDiv);
          msgDiv.appendChild(contentDiv);
          msgDiv.appendChild(editArea);
          msgDiv.appendChild(editActionsContainer);

          container.appendChild(msgDiv);

          renderMathInElement(msgDiv, {
            delimiters: [
              { left: "$$", right: "$$", display: true },
              { left: "$", right: "$", display: false },
            ],
            output: "htmlAndMathml", // This is usually default, but good to be explicit
            throwOnError: false,
          });

          // Tell Prism to highlight any code blocks in this message
          Prism.highlightAllUnder(msgDiv);
        });

        // Handle scroll position
        if (preserveScroll) {
          container.scrollTop = prevScroll;
        } else {
          const lastMsg = container.lastElementChild;
          if (lastMsg) {
            // Scroll so the top of the last message is at the top of the container
            // Subtracting 15px to account for the container's padding so it looks clean
            container.scrollTop = lastMsg.offsetTop - 15;
          }
        }
      }

      // --- API INTERACTION ---
      async function sendMessage() {
        const inputEl = document.getElementById("chat-input");
        const text = inputEl.value.trim();
        if (!text) return;

        if (!config.key) {
          alert("Please enter your API key in the settings first.");
          return;
        }

        if (!currentChatId) newChat();
        const chat = chats.find((c) => c.id === currentChatId);

        // Auto-title if it's the first message
        if (chat.messages.length === 0) {
          chat.title = text.substring(0, 30) + (text.length > 30 ? "..." : "");
        }

        // Add user message
        chat.messages.push({ role: "user", content: text });
        inputEl.value = "";
        saveState();
        renderApp(); // Scroll to top of new message

        const btn = document.getElementById("send-btn");
        const model = document.getElementById("model-select").value;

        btn.disabled = true;
        btn.textContent = "Thinking...";

        try {
          // Strip out any system errors before sending to API
          const cleanMessages = chat.messages
            .filter((m) => m.role !== "system")
            .map((m) => ({ role: m.role, content: m.content }));

          const response = await fetch(`${config.url}/chat/completions`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${config.key}`,
            },
            body: JSON.stringify({
              model: model,
              messages: cleanMessages,
            }),
          });

          if (!response.ok) {
            const errData = await response.json().catch(() => ({}));
            throw new Error(errData.error?.message || `HTTP ${response.status} ${response.statusText}`);
          }

          const data = await response.json();
          const reply = data.choices[0].message.content;

          chat.messages.push({ role: "assistant", content: reply });
        } catch (error) {
          chat.messages.push({ role: "system", content: `**Error:**\n\n${error.message}` });
        }

        btn.disabled = false;
        btn.textContent = "Send";
        saveState();
        renderApp(); // Scroll to top of new message
      }

      // --- KEYBOARD SHORTCUTS ---

      // Allow Ctrl+Enter to send
      document.getElementById("chat-input").addEventListener("keydown", function (e) {
        if ((e.ctrlKey || e.metaKey) && e.key === "Enter") {
          sendMessage();
        }
      });

      // Global shortcuts because clicking is for chumps
      document.addEventListener("keydown", function (e) {
        // Alt+T for New Chat
        if (e.altKey && e.key.toLowerCase() === "t") {
          e.preventDefault(); // Stop any default browser bullshit
          newChat();
          // Focus the input so they can start typing immediately
          document.getElementById("chat-input").focus();
        }

        // Alt+W for Delete Current Chat
        if (e.altKey && e.key.toLowerCase() === "w") {
          e.preventDefault();
          if (currentChatId) {
            if (confirm("Are you sure you want to nuke this chat?")) {
              deleteChat(currentChatId);
            }
          }
        }

        // Alt+R for Rename Current Chat
        if (e.altKey && e.key.toLowerCase() === "r") {
          e.preventDefault();
          renameChat(currentChatId);
        }

        // Alt+P for toggle hide sidebar
        if (e.altKey && e.key.toLowerCase() === "p") {
          e.preventDefault();
          toggleSidebar();
        }

        // Alt+O for toggle hide title
        if (e.altKey && e.key.toLowerCase() === "o") {
          e.preventDefault();
          toggleTitle();
        }

        // Alt+Up / Alt+Down to cycle through messages
        if (e.altKey && (e.key === "ArrowUp" || e.key === "ArrowDown")) {
          e.preventDefault();

          const container = document.getElementById("chat-container");
          const msgs = Array.from(container.querySelectorAll(".msg"));
          if (msgs.length === 0) return;

          const currentScroll = container.scrollTop;
          const offsetAdjustment = 15; // Matches the padding-top of the container
          const threshold = 5; // Pixel tolerance for rounding errors

          if (e.key === "ArrowDown") {
            // Find the first message below the current scroll position
            const nextMsg = msgs.find((m) => m.offsetTop - offsetAdjustment > currentScroll + threshold);
            if (nextMsg) {
              container.scrollTop = nextMsg.offsetTop - offsetAdjustment;
            } else {
              // Already at the bottom message, scroll to the very bottom of the container
              container.scrollTop = container.scrollHeight;
            }
          } else if (e.key === "ArrowUp") {
            // Find the last message above the current scroll position
            const prevMsg = msgs
              .slice()
              .reverse()
              .find((m) => m.offsetTop - offsetAdjustment < currentScroll - threshold);
            if (prevMsg) {
              container.scrollTop = prevMsg.offsetTop - offsetAdjustment;
            } else {
              // Already at the top message, scroll to the absolute top
              container.scrollTop = 0;
            }
          }
        }
      });

      // --- CLIPBOARD SHIT ---

      // Toggle the copy-mode class based on key state
      const toggleCopyMode = (e) => {
        if (e.key === "Control" || e.key === "Meta") {
          document.body.classList.toggle("ctrl-down", e.type === "keydown");
        }
      };
      window.addEventListener("keydown", toggleCopyMode);
      window.addEventListener("keyup", toggleCopyMode);

      document.getElementById("chat-container").addEventListener("click", function (e) {
        if (!(e.ctrlKey || e.metaKey)) return;

        let text = "";
        let target = null;

        // Check if it's a code block
        const codeTarget = e.target.closest("pre") || e.target.closest("code");

        // Check if it's a KaTeX math block
        const mathTarget = e.target.closest(".katex");

        if (mathTarget) {
          target = mathTarget;
          // KaTeX stores the original LaTeX in an <annotation> tag
          const annotation = mathTarget.querySelector("annotation");
          if (annotation) {
            text = annotation.textContent;
          } else {
            // Fallback for some configurations: try to find the TeX source
            text = mathTarget.querySelector(".katex-mathml math").getAttribute("alttext") || "";
          }
        } else if (codeTarget) {
          target = codeTarget;
          text = target.innerText;
        }

        if (!target || !text) return;

        e.preventDefault();
        navigator.clipboard.writeText(text).then(() => {
          const originalBg = target.style.backgroundColor;
          target.style.backgroundColor = "#ccc";
          setTimeout(() => {
            target.style.backgroundColor = originalBg;
          }, 100);
        });
      });

      // Boot this shit up
      init();
    </script>
  </body>
</html>
